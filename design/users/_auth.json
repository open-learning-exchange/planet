{"validate_doc_update":"function(newDoc, oldDoc, userCtx, secObj) {\r\n    if (newDoc._deleted === true) {\r\n      // allow deletes by admins and matching users\r\n      // without checking the other fields\r\n      // and forbid deleting admin's user doc\r\n      if (((userCtx.roles.indexOf('_admin') !== -1) ||\r\n        (userCtx.name == oldDoc.name)) &&\r\n        (oldDoc.isUserAdmin !== true || oldDoc.roles.length > 0)) {\r\n        return;\r\n      } else {\r\n        throw({forbidden: oldDoc.isUserAdmin === true ? 'Deleting admin is not permitted' : 'Only admins may delete other user docs.'});\r\n      }\r\n    }\r\n\r\n    if (newDoc.type !== 'user') {\r\n      throw({forbidden : 'doc.type must be user'});\r\n    } // we only allow user docs for now\r\n\r\n    if (!newDoc.name) {\r\n      throw({forbidden: 'doc.name is required'});\r\n    }\r\n\r\n    if (!newDoc.roles) {\r\n      throw({forbidden: 'doc.roles must exist'});\r\n    }\r\n\r\n    if (!isArray(newDoc.roles)) {\r\n      throw({forbidden: 'doc.roles must be an array'});\r\n    }\r\n\r\n    if (newDoc.roles.indexOf('openlearner') > -1) {\r\n      throw({forbidden: 'Role not allowed'});\r\n    }\r\n\r\n    for (var idx = 0; idx < newDoc.roles.length; idx++) {\r\n      if (typeof newDoc.roles[idx] !== 'string') {\r\n        throw({forbidden: 'doc.roles can only contain strings'});\r\n      }\r\n    }\r\n\r\n    if (newDoc._id !== ('org.couchdb.user:' + newDoc.name)) {\r\n      throw({\r\n        forbidden: 'Doc ID must be of the form org.couchdb.user:name'\r\n      });\r\n    }\r\n\r\n    if (oldDoc) { // validate all updates\r\n      if (oldDoc.name !== newDoc.name) {\r\n        throw({forbidden: 'Usernames can not be changed.'});\r\n      }\r\n    }\r\n\r\n    if (newDoc.password_sha && !newDoc.salt) {\r\n      throw({\r\n        forbidden: 'Users with password_sha must have a salt.' +\r\n          'See /_utils/script/couch.js for example code.'\r\n      });\r\n    }\r\n\r\n    if (newDoc.password_scheme === 'pbkdf2') {\r\n      if (typeof(newDoc.iterations) !== 'number') {\r\n         throw({forbidden: 'iterations must be a number.'});\r\n      }\r\n      if (typeof(newDoc.derived_key) !== 'string') {\r\n         throw({forbidden: 'derived_key must be a string.'});\r\n      }\r\n    }\r\n\r\n    var is_server_or_database_admin = function(userCtx, secObj) {\r\n      // see if the user is a server admin\r\n      if(userCtx.roles.indexOf('_admin') !== -1) {\r\n        return true; // a server admin\r\n      }\r\n\r\n      // see if the user a database admin specified by name\r\n      if(secObj && secObj.admins && secObj.admins.names) {\r\n        if(secObj.admins.names.indexOf(userCtx.name) !== -1) {\r\n          return true; // database admin\r\n        }\r\n      }\r\n\r\n      // see if the user a database admin specified by role\r\n      if(secObj && secObj.admins && secObj.admins.roles) {\r\n        var db_roles = secObj.admins.roles;\r\n        for(var idx = 0; idx < userCtx.roles.length; idx++) {\r\n          var user_role = userCtx.roles[idx];\r\n          if(db_roles.indexOf(user_role) !== -1) {\r\n            return true; // role matches!\r\n          }\r\n        }\r\n      }\r\n\r\n      return false; // default to no admin\r\n    }\r\n\r\n    var filterDifferentRoles = function(array) {\r\n      return function(role) { return array.indexOf(role) === -1 };\r\n    }\r\n\r\n    var combineArrays = function(array1, array2) {\r\n      return array1.concat(array2.filter(filterDifferentRoles(array1)));\r\n    }\r\n\r\n    var onlyLearnerChange = function(oldRoles, newRoles) {\r\n      var removedRoles = oldRoles.filter(filterDifferentRoles(newRoles));\r\n      var addedRoles = newRoles.filter(filterDifferentRoles(oldRoles));\r\n      var changedRoles = combineArrays(removedRoles, addedRoles);\r\n      return changedRoles.length === 1 && changedRoles[0] === 'learner';\r\n    }\r\n\r\n    if (!is_server_or_database_admin(userCtx, secObj)) {\r\n      var openLearnerRole = secObj.admins.roles.indexOf('openlearner') > -1;\r\n      if (oldDoc) { // validate non-admin updates\r\n        if (userCtx.name !== newDoc.name) {\r\n          throw({\r\n            forbidden: 'You may only update your own user document.'\r\n          });\r\n        }\r\n        // validate role updates\r\n        var oldRoles = (oldDoc.roles || []).sort();\r\n        var newRoles = newDoc.roles.sort();\r\n\r\n        if (openLearnerRole && onlyLearnerChange(oldRoles, newRoles)) {\r\n          return;\r\n        }\r\n\r\n        if (oldRoles.length !== newRoles.length) {\r\n          throw({forbidden: 'Only _admin may edit roles'});\r\n        }\r\n\r\n        for (var i = 0; i < oldRoles.length; i++) {\r\n          if (oldRoles[i] !== newRoles[i]) {\r\n            throw({forbidden: 'Only _admin may edit roles'});\r\n          }\r\n        }\r\n      } else if (newDoc.roles.length > 0) {\r\n        if (!openLearnerRole || newDoc.roles.length > 1 || newDoc.roles[0] !== 'learner') {\r\n          throw({forbidden: 'Only _admin may set roles'});\r\n        }\r\n      }\r\n    }\r\n\r\n    // no system roles in users db\r\n    for (var i = 0; i < newDoc.roles.length; i++) {\r\n      if (newDoc.roles[i][0] === '_') {\r\n        throw({\r\n          forbidden:\r\n          'No system roles (starting with underscore) in users db.'\r\n        });\r\n      }\r\n    }\r\n\r\n    // no system names as names\r\n    if (newDoc.name[0] === '_') {\r\n      throw({forbidden: 'Username may not start with underscore.'});\r\n    }\r\n\r\n    var badUserNameChars = [':'];\r\n\r\n    for (var i = 0; i < badUserNameChars.length; i++) {\r\n      if (newDoc.name.indexOf(badUserNameChars[i]) >= 0) {\r\n        throw({forbidden: 'Character `' + badUserNameChars[i] +\r\n            '` is not allowed in usernames.'});\r\n      }\r\n    }\r\n  }"}